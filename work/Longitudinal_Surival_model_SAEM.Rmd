---
title: "Longitudinal and survival data modelisation"
author: "Antoine caillebotte"
date: "`r Sys.time()`"
output: html_document
---

<style type="text/css">
.main-container {
  max-width: 1000px;
  margin-left: auto;
  margin-right: auto;
}
</style>
  
```{r setup, include = F}
library(knitr)
library(kableExtra)
rm(list = ls())

opts_chunk$set(echo = T, message = F, warning = F,
               fig.width = 12, fig.asp = 0.8,
               fig.align = "center",
               out.weightedidth = "100%")

library(SAEM4JLS)
```

## Initialisation et génération des données

```{r number of cores, echo = F}
ncores <- pmin(1, future::availableCores()-1 )
message(paste('number of cores available =', ncores))
print(paste('number of cores available =', ncores))
```

```{r init}
#Phi[1] ; eta = valeur de fin  Phi[2] = valeur du noeud  Phi[3] = echelle
m <- function(t, eta, phi) (phi[,1] + eta)/(1+exp((phi[,2]-t)/phi[,3]))
#=======================================#
param <- list(sigma2 = 0.05,
              rho2 = 0.1,
              mu = c(5,90,5),
              omega2 = c(0.5,0.1,0.01),
              #Survival data,
              nu2 = 0.5,
              a = 90,
              b = 50,
              alpha = 7,
              beta = 10)

#=======================================#
t <- seq(60,120, length.out = 10) #value of times

data <- JLS_data(G = 2, ng = 4, time = t, fct = m, param = param)

getDim(data)
Y <- data$obs
```

```{r data ploting, echo = F}
plot(data, nrow = 2)
```

# Statistique exhaustive
$$\log f(Y, Z ; \theta) = \langle \Phi(\theta) ; S(Y,Z) \rangle - \psi(\theta)$$

```{r  stat exhaustive}
sigma2_a <- sigma2_b <- sigma2_alpha <- 0.1

Phi <- fct_vector(function(sigma2, rho2, mu, omega2, nu2, a, b, alpha, beta) {
  c(- n/(2*sigma2), -N/(2*rho2),               #1, 2
        - G/(2*omega2), G*mu/omega2,               #3, 4
        - G/(2*nu2),                               #5
          a/sigma2_a,         -1/(2*sigma2_a),     #6, 7
          b/sigma2_b        , -1/(2*sigma2_b),     #8, 9
          alpha/sigma2_alpha, -1/(2*sigma2_alpha), #10, 11
          beta ) },#12
  dim = c(1,1,F., F., rep(1,8)) )$eval

zeta <- function(beta, eta, phi, gamma, a,b, alpha)
{
  lbd <- function(t,g) t^{b-1} * exp(alpha*m(t, eta[g], phi[g,]))
  P1 <- 1:nrow(data@survival) %>% 
    sapply(function(i) integrate(function(t) lbd(t,data$gen[i]), 0, data$obs[i])$value )
  
  P2 <- 1:nrow(data@survival) %>% 
    sapply(function(i) exp(beta*data$U[i] + gamma[data$gen[i]] )  )
  
  beta*sum(data@survival$U) -  b*a^-b * sum(P2*P1)
}
zeta.der <- function(beta, eta, phi, gamma, a, b, alpha)
{
  lbd <- function(t,g) t^{b-1} * exp(alpha*m(t, eta[g], matrix(phi[g,], nrow = 1)))
  P1 <- 1:nrow(data@survival) %>% 
    sapply(function(i) integrate(function(t) lbd(t,data$gen[i]) , 0, data$obs[i])$value )
  
  P2 <- 1:nrow(data@survival) %>% 
    sapply(function(i) data@survival$U[i]*exp(beta*data@survival$U[i] + gamma[data$gen[i]] )  )
  
  sum(data@survival$U) -  b*a^-b * sum(P2*P1)
}

S <- fct_vector(function(eta, phi, ...) mean((Y - get_obs(data, eta = eta, phi = phi) )^2 ),
                function(eta, ...)      mean(eta^2),           #2
                function(phi, ...)      apply(phi^2, 2, mean), #3
                function(phi, ...)      apply(phi, 2, mean),   #4
                function(gamma, ...)    mean(gamma^2),         #5
                function(a, ...)        a,                     #6
                function(a, ...)        a^2,                   #7
                function(b, ...)        b,                     #8
                function(b, ...)        b^2,                   #9
                function(alpha, ...)    alpha,                 #10
                function(alpha, ...)    alpha^2,               #11
                function(eta, phi, gamma, a, b, alpha)                        #12
                  param$beta,
                  #uniroot(function(beta)zeta.der(beta, eta, phi, gamma, a,b,alpha), lower = -100, upper = 100, tol = 1e-3)$root,
                dim = c(1,1,F., F., rep(1,8)) ) 
```

# Metropolis Hastings
## Vraisemblance
```{r MH}
loglik.phi <- function(x, eta, Phi){
  id <- c(1,3,4)
  sum( Phi%a%id * S$eval(eta = eta, phi = x, i = id) )
}
loglik.eta <- function(x, phi, Phi){ 
  id <- c(1,2)
  sum( Phi%a%id * S$eval(eta = x, phi = phi, i = id) )
}

loglik.gamma <- function(x, eta, phi, a, b, alpha, Phi){
  Phi%a%5  * sum(x^2) + ng*sum(x) +
    zeta(Phi%a%12, eta, phi, x, a, b, alpha) #Correction fait à la va vite
}

#c'est faux à refaire !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
loglik.a <- function(x, b, Phi) sum( Phi%a%6:7 * S$eval(a = x, b = b, i = 6:7) ) + G*ng*log(b*x^-b)
loglik.b <- function(x, Phi)    sum( Phi%a%8:9 * S$eval(b = x, i = 8:9) ) + (x-1)*sum(log(t))
loglik.alpha <- function(x, Phi)sum( Phi%a%10:11 * S$eval(alpha = x, i = 10:11) )
```

# SAEM
## initialisation
```{r SAEM init}
# ---  Initialisation des paramètres --- #
para <- param %>% sapply(function(x) x* runif(1, 1.1,1.4))
para$rho2 = 0.2 ; para$omega2 <- rep(.1,3)

# --- Initialisation des chaines MC : Z_0 --- #
Z <- list(eta = list(matrix(rnorm(G*ng, 0, para$rho2),         ncol = 1)),
          phi = list(matrix(rnorm(F.*G, para$mu, para$omega2), nrow = F.) %>% t ),
          
          gamma = list(data@gamma),#matrix(rnorm(G, 0, para$nu2), ncol = 1) ),
          
          a = list(matrix(param$a)),
          b = list(matrix(param$b)),
          alpha = list(matrix(param$alpha))
          )

```

## Etape simulation et maximisation du SEAM
```{r SAEM fct}
sim <- function(niter, k, Phih, eta, phi, gamma, a, b, alpha)
{
  # eta <- list(MH_High_Dim_para_future(niter, eta[[1]], sd = sd.eta(k), loglik.eta, phi[[1]], 
  #                                     Phih, cores = ncores ))

  phi <- list(MH_High_Dim_para_future(niter, phi[[1]], sd = sd.phi(k), loglik.phi, eta[[1]], 
                                      Phih, cores = ncores ))
  
  # gamma <- 1:M %>% lapply( function(i)
  #   MH_High_Dim_para_future(niter, gamma[[i]], sd = .03, loglik.gamma, 
  #                    eta[[i]], phi[[i]], a[[i]], b[[i]], alpha[[i]], 
  #                    Phih, cores = 1 ))

  # a <- 1:M %>% lapply( function(i) MH_High_Dim_para_future(niter, a[[i]],     sd = .02, loglik.a,b[[i]],  Phih, cores = 1 ))
  # b <- 1:M %>% lapply( function(i) MH_High_Dim_para_future(niter, b[[i]],     sd = .02, loglik.b,         Phih, cores = 1 ))
  # alpha <- 1:M %>% lapply( function(i) MH_High_Dim_para_future(niter, alpha[[i]], sd = .02, loglik.alpha, Phih, cores = 1 ))

  list(eta = eta, phi = phi, gamma = gamma, a = a, b = b, alpha = alpha)
}

maxi <- function(S)
{
  return(param)
  list(sigma2 = S%a%1,
       rho2 =   S%a%2,
       mu =     S%a%4,
       omega2 = S%a%3 - (S%a%4)^2,
       nu2 =    S%a%5,
       a =      S%a%6,  b =    S%a%8,
       alpha =  S%a%10, beta = S%a%12 )
}

```

# Resultats

```{r oracle, echo = F, results='asis'}
data.frame( Oracle = maxi(S$eval(attr(dt_NLME, 'eta'), attr(dt_NLME, 'phi'), 
                            attr(dt_SF, 'gamma'), param$a, param$b, param$alpha  )) %>% unlist ,
            Initialisation = para%>% unlist)%>% t %>% round(digits = 4) %>% 
  knitr::kable(format = 'html') %>% kable_styling(full_width = F)
```
```{r eval=FALSE, include=FALSE}
res <- MH_High_Dim_para_future(500, Z$phi[[1]], sd = c(.3,.5,.3), loglik.phi, 
                               Z$eta[[1]], do.call(Phi, param), 
                        cores = ncores, verbatim = T )
plot(res, nrow = 2)

```

```{r SAEM loop }
niter <- 10
correction.phase <- 20
MH.iter <- function(k) ifelse(k<2*correction.phase, 20, 10)

sd.eta <- function(k) 0.04
sd.phi <- function(k) c(.3,.5,.3)

res <- SAEM(niter, MH.iter, para, Phi, S$eval, Z, sim, maxi, eps = 1e-3, verbatim = 2)
saveRDS(res, 'saem.rds')
gg <- plot(res, true.value = param)
```

```{r seam table, results='asis', echo = F }
gg$table_estimation
```

```{r saem plot, echo = F }
gg$plot_parameter# %>% vline(correction.phase, 'purple') %>% vline(2*correction.phase, 'orange') 
gg$plot_MCMC# %>% vline(correction.phase, 'purple') %>% vline(2*correction.phase, 'orange') 

gg.MH <- names(res@Z) %>% keep(function(var) 'MH_res' %in% class(res@Z[[var]][[1]]) ) %>%
  lapply(function(var)plot(res@Z[[var]][[1]], name = var, var = 'acceptation'))

grid.arrange(grobs  = gg.MH)
```










