---
title: "Longitudinal and survival data modelisation"
author: "Antoine caillebotte"
date: "`r Sys.time()`"
output: html_document
---

<style type="text/css">
.main-container {
  max-width: 1000px;
  margin-left: auto;
  margin-right: auto;
}
</style>
  
```{r setup, include = F}
library(knitr)
library(kableExtra)

rm(list = ls())

opts_chunk$set(echo = T, message = F, warning = F,
               fig.width = 12, fig.asp = 0.8,
               fig.align = "center",
               out.weightedidth = "100%")

folder <- '../R/'
source('../R/include.R')
```

## Initialisation

```{r number of cores, echo = F}
ncores <- future::availableCores()
message(paste('number of cores available =', ncores))
print(paste('number of cores available =', ncores))
```

```{r init}
#Phi[1] ; eta = valeur de fin
#Phi[2] = valeur du noeud
#Phi[3] = echelle
m <- function(t, eta, phi) (phi[1] + eta)/(1+exp((phi[2]-t)/phi[3]))
#=======================================#
param <- list(sigma2 = 0.05,
              rho2 = 0.1,
              mu = c(5,90,5),
              omega2 = c(0.5,0.1,0.01),
              #Survival data,
              nu2 = 0.5,
              a = 90,
              b = 50,
              alpha = 7,
              beta = 10)

F. <- length(param$omega2) #dimension de phi
#=======================================#
t <- seq(60,120, length.out = 10) #value of times

# --- longitudinal data --- #
G = 40 ; ng = 4 #nombre de groupe et d'individu par groupe
n <- G*ng*length(t) ; N <- G*ng  #nombre total de data, et #nombre total d'individu

dt_NLME <- NLME_obs(G, ng, t, param, m)
Y <- dt_NLME$obs
dt_SF <- SF_obs(dt_NLME, param, m)
```

```{r data ploting, echo = F}
dt_NLME %>% ggplot(aes(t, obs, col = gen, group = id)) + 
  geom_point() + geom_line() + theme(legend.position = 'null')

# --- Survival data --- #
dt_SF %>% ggplot(aes(obs, fill = factor(U))) + 
  geom_histogram(col = 'white', position = 'identity', bins = 30) + theme(legend.position = 'null')
```

## SAEM avec simulation par MCMC
$$\log f(Y, Z ; \theta) = \langle \Phi(\theta) ; S(Y,Z) \rangle - \psi(\theta)$$

```{r  stat exhaustive}
sigma2_a <- sigma2_b <- sigma2_alpha <- 0.1

#Petite fonction pour retourner rapidement l'appel Phi[attr(Phi, i)] où i est '1', '2', ...,
`%a%` <- function(x,var) x[ attr(x,as.character(var)) ]

Phi <- function(sigma2, rho2, mu, omega2, nu2, a, b, alpha, beta)
{
  p <-c(- n/(2*sigma2), -N/(2*rho2),               #1, 2
        - G/(2*omega2), G*mu/omega2,               #3, 4
        - G/(2*nu2),                               #5
          a/sigma2_a,         -1/(2*sigma2_a),     #6, 7
          b/sigma2_b        , -1/(2*sigma2_b),     #8, 9
          alpha/sigma2_alpha, -1/(2*sigma2_alpha), #10, 11
          beta )                                   #12

  attr(p, '1') <- 1
  attr(p, '2') <- 2
  attr(p, '3') <- 2 + 1:length(mu)
  attr(p, '4') <- 2 +   length(mu) + 1:length(mu)
  attr(p, '5') <- 2 + 2*length(mu) + 1
  
  for(i in 6:12) attr(p, as.character(i)) <- attr(p, as.character(i-1)) + 1 
  return(p)
}

zeta <- function(beta, eta, phi, gamma, a,b, alpha)
{
  lbd <- function(t,g) t^{b-1} * exp(alpha*m(t, eta[g], phi[g,]))
  P1 <- 1:nrow(dt_SF) %>% sapply(function(i) integrate(function(t) lbd(t,dt_SF$gen[i]) , 0, dt_SF$obs[i])$value )
  
  P2 <- 1:nrow(dt_SF) %>% sapply(function(i) exp(beta*dt_SF$U[i] + gamma[dt_SF$gen[i]] )  )
  
  beta*sum(dt_SF$U) -  b*a^-b * sum(P2*P1)
}
zeta.der <- function(beta, eta, phi, gamma, a, b, alpha)
{
  lbd <- function(t,g) t^{b-1} * exp(alpha*m(t, eta[g], phi[g,]))
  P1 <- 1:nrow(dt_SF) %>% sapply(function(i) integrate(function(t) lbd(t,dt_SF$gen[i]) , 0, dt_SF$obs[i])$value )
  
  P2 <- 1:nrow(dt_SF) %>% sapply(function(i) dt_SF$U[i]*exp(beta*dt_SF$U[i] + gamma[dt_SF$gen[i]] )  )
  
  sum(dt_SF$U) -  b*a^-b * sum(P2*P1)
}

S <- function(eta, phi, gamma, a, b, alpha)
{
  beta <- uniroot(function(beta)zeta.der(beta, eta, phi, gamma, a,b,alpha), lower = -100, upper = 100)$root
  
  s <- c(mean((Y - get_obs(m, dt_NLME, eta = eta, phi = phi) )^2 ), #1
         mean(eta^2),                                               #2
         apply(phi^2, 2, mean), apply(phi  , 2, mean),              #3 et 4
         mean(gamma^2),                                             #5
         a, a^2,                                                    #6 et 7
         b, b^2,                                                    #8 et 9
         alpha^2, alpha,                                            #10 et 11
         beta )                                                     #12

  attr(s, '1') <- 1
  attr(s, '2') <- 2
  attr(s, '3') <- 2 + 1:ncol(phi)
  attr(s, '4') <- 2 +   ncol(phi) + 1:ncol(phi)
  attr(s, '5') <- 2 + 2*ncol(phi) + 1
  
  for(i in 6:12) attr(s, as.character(i)) <- attr(s, as.character(i-1)) + 1 
  return(s)
}
```

---

```{r MH}
#=============================================================================#
loglik.phi <- function(x, eta, Phi)
{
  Phi%a%1 * sum((Y - get_obs(m, dt_NLME, eta = eta, phi = x) )^2) +
    Phi%a%3 * apply(x^2, 2, sum) + Phi[4] * apply(x  , 2, sum)
}
loglik.eta <- function(x, phi, Phi) 
{ 
  Phi%a%1 * sum((Y - get_obs(m, dt_NLME, eta = x, phi = phi) )^2) + 
    Phi%a%2 * sum(x^2)
}

loglik.gamma <- function(x, eta, phi, a, b, alpha, Phi)
{
  Phi%a%5  * sum(x^2) + ng*sum(x) +
    zeta(Phi%a%12, eta, phi, x, a, b, alpha) #Correction fait à la va vite
}

loglik.a     <- function(x, b, Phi) Phi%a%6  * x + Phi%a%7 * x^2  + G*ng*log(b*x^-b)
loglik.b     <- function(x, Phi) Phi%a%8  * x + Phi%a%9 * x^2  + (x-1)*sum(log(t))
loglik.alpha <- function(x, Phi) Phi%a%10 * x + Phi%a%11 * x^2
```

# SAEM
### Initialisation
```{r SAEM init}
M <- 1 #nombre de simulation
u <- function(k) ifelse(k<200, 1, 1/(k-199) )

# ---  Initialisation des paramètres --- #
para <- param %>% lapply(function(x) x + 2*runif(1) )

# --- Initialisation des chaines MC : Z_0 --- #list(attr(dt_NLME,'eta')),#
Z <- list(eta = list(attr(dt_NLME,'eta')),#1:M %>% lapply(function(i) rnorm(G*ng, 0, para$rho2)  %>% matrix(ncol = 1) ),
          phi = list(attr(dt_NLME,'phi')),#1:M %>% lapply(function(i) matrix(rnorm(F.*G, para$mu, para$omega2), nrow = F.) %>% t ),
          
          gamma = 1:M %>% lapply(function(i) matrix(rnorm(G, 0, para$nu2), ncol = 1) ),
          
          a = list(matrix(param$a)),
          b = list(matrix(param$b)),
          alpha = list(matrix(param$alpha)) )
```

## Boucle

```{r SAEM fct}
sim <- function(niter, Phih, eta, phi, gamma, a, b, alpha)
{
  M <- length(phi)

  # eta <- 1:M %>% lapply( function(i)
  #   MH_High_Dim_para_future(niter, eta[[i]],   sd = .02,              loglik.eta, phi[[i]], Phih, cores = ncores-1 ))
  #                  |                                         |                     |
  # phi <- 1:M %>% lapply( function(i) #                         |                     |
  #   MH_High_Dim_para_future(niter, phi[[i]],   sd = c(.03, .02, .02), loglik.phi, eta[[i]], Phih, cores = ncores-1 ))
  #                  |                                         |                     |
  gamma <- 1:M %>% lapply( function(i)#                        |                     |
    MH_High_Dim_para_future(niter, gamma[[i]], sd = .03, loglik.gamma, 
                     eta[[i]], phi[[i]], a[[i]], b[[i]], alpha[[i]], 
                     Phih, cores = ncores-1 ))

  # a <- 1:M %>% lapply( function(i) MH_High_Dim_para_future(niter, a[[i]],     sd = .02, loglik.a,b[[i]],  Phih, cores = 1 ))
  # b <- 1:M %>% lapply( function(i) MH_High_Dim_para_future(niter, b[[i]],     sd = .02, loglik.b,         Phih, cores = 1 ))
  # alpha <- 1:M %>% lapply( function(i) MH_High_Dim_para_future(niter, alpha[[i]], sd = .02, loglik.alpha, Phih, cores = 1 ))

  list(eta = eta, phi = phi, gamma = gamma, a = a, b = b, alpha = alpha)
}

maxi <- function(S)
{
  list(sigma2 = S%a%1,
       rho2 =   S%a%2,
       mu =     S%a%4,
       omega2 = S%a%3 - (S%a%4)^2,
       nu2 =    S%a%5,
       a =      S%a%6,  b =    S%a%8,
       alpha =  S%a%11, beta = S%a%12 )
}
```

```{r oracle, echo = F, results='asis'}
maxi(S(attr(dt_NLME, 'eta'), attr(dt_NLME, 'phi'), attr(dt_SF, 'gamma'), param$a, param$b, param$alpha  )) %>% 
  unlist %>% t %>% knitr::kable(caption = "Estimation oracle", format = 'html') %>%
      kable_styling(full_width = F)
```

```{r SAEM loop}
niter <- 100
MH.iter <- 10
res <- SAEM(niter, MH.iter, u, para, Phi, S, Z, sim, maxi, eps = 1e-1, verbatim = T)
saveRDS(res, 'saem.rds')
gg <- plot(res)
```

```{r seam table, results='asis', echo = F}
gg$table_estimation
```

```{r saem plot, echo = F}
gg$plot_paramater
gg$plot_MCMC

gg.MH <- names(res$Z) %>% keep(function(var) 'MH_res' %in% class(res$Z[[var]][[1]]) ) %>%
  lapply(function(var)plot(res$Z[[var]][[1]], name = var)$plot_acceptation)

grid.arrange(grobs  = gg.MH)
```










