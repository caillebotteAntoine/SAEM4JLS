---
title: "prox JLS SAEM"
author: "Antoine caillebotte"
date: "`r Sys.time()`"
output: html_document
---

<style type="text/css">
.main-container {
  max-width: 1000px;
  margin-left: auto;
  margin-right: auto;
}
</style>
  
```{r setup, include = F}
library(knitr)
library(kableExtra)

knitr::knit_hooks$set(time = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- Sys.time()
    } else {
      # calculate the time difference after a chunk
      res <- difftime(Sys.time(), now, units = 's')
      # return a character string to show the time
      diff_time <- format(as.POSIXct(as.numeric(res), 
                                     origin = '1970-01-01', tz = 'UTC'), "%Mmin %Ssec")
      paste("Chunk execution time = ", diff_time)
    }
  }
}))

rm(list = ls())

opts_chunk$set(echo = T, message = F, warning = F,
               fig.weightedidth = 12,
               fig.asp = 0.8,
               out.weightedidth = "100%")

require(SAEM4JLS)
require(tictoc)
```



```{r}
#Phi[1] ; eta = valeur de fin  Phi[2] = valeur du noeud  Phi[3] = echelle
m1 <- function(t, phi1, phi2, phi3, eta) phi1 + eta
m2 <- function(t, phi1, phi2, phi3, eta) 1/(1+exp((phi2-t)/phi3))
m <-  function(t, phi1, phi2, phi3, eta) m1(t,phi1, phi2, phi3, eta) * m2(t,phi1, phi2, phi3,eta)
#=======================================#
G <- 8
ng <- 4
N <- G*ng
t <- seq(60,120, length.out = 10) #value of times
nt <- length(t)
n <- length(t) * N
#=======================================#
param <- list(sigma2 = 0.05,
              mu = c(90,90,5),
              omega2 = c(20, 40,1) )
#=======================================#

var.true <- list()
var.true$phi1 <- rnorm(G, param$mu[1], sqrt(param$omega2[1]))
var.true$phi2 <- rnorm(G, param$mu[2], sqrt(param$omega2[2]))
var.true$phi3 <- rnorm(G, param$mu[3], sqrt(param$omega2[3]))


p <- 2
U <- matrix(runif(N*p), nrow = N, ncol = p)#1e4*as.matrix(x)
tU <- t(U)
beta <- matrix(rep(0, p), nrow = 1) ; beta[sample(1:p, 1)] <- 1



time <- rep(t, N)


get_obs <- function(phi1, phi2, phi3, beta, ...){
  m( time,
     rep(phi1, each = ng*length(t)),
     rep(phi2, each = ng*length(t)),
     rep(phi3, each = ng*length(t)),
     rep( as.vector(beta %*% tU), each = length(t)) )
}

get_obs <- function(phi1, phi2, phi3, beta, ...){
  m( time,
     rep(phi1, each = ng*length(t)),
     rep(phi2, each = ng*length(t)),
     rep(phi3, each = ng*length(t)),
     rep( as.vector(beta %*% tU), each = length(t)) )
}


get_obs_i <- function(phi1, phi2, phi3, beta, i){
  m(t, 
    rep(var.true$phi1[(i-1)%%G+1], each = length(t)),
    rep(var.true$phi2[(i-1)%%G+1], each = length(t)),
    rep(var.true$phi3[(i-1)%%G+1], each = length(t)), 
    sum(beta %*% tU[,i]))
}

get_m_denom_i <- function(phi1, phi2, phi3, beta, i){
  m2(t, 
    rep(var.true$phi1[(i-1)%%G+1], each = length(t)),
    rep(var.true$phi2[(i-1)%%G+1], each = length(t)),
    rep(var.true$phi3[(i-1)%%G+1], each = length(t)), 
    sum(beta %*% tU[,i]))
}

# data <- data.frame(id = rep(1:N, each = length(t)) , time = rep(t, N), gen = rep(1:G, each = ng*length(t))) %>%
#   mutate(obs = get_obs(beta, phi) + eps)

Y <- get_obs(var.true$phi1, var.true$phi2, var.true$phi3, beta) + rnorm(n, mean = 0 , sd = sqrt(param$sigma2) )
```

```{r data ploting, echo = F}
data.frame(time, Y, id = rep(1:N, each = length(t)), gen = rep(1:G, each = ng*length(t)) ) %>%
  ggplot(aes(time, Y, col = factor(gen), group = factor(id) )) +
  geom_point() + geom_line() +
  theme(legend.position = 'null')
```


```{r SPGD}

proxi <- function(theta, gamma, alpha, lambda)
{
  coef <- ifelse(theta > gamma*alpha*lambda, theta-gamma*alpha*lambda,
                 ifelse(theta < -gamma*alpha*lambda, theta+gamma*alpha*lambda, 0))
  1/(1+gamma*lambda*(1-alpha)) * coef
}

prox <- function(theta, gamma, alpha, lambda) sapply(theta, proxi, gamma, alpha, lambda)

SPGD <- function(niter, m, theta0, n, step = 1e-6, grad.fi, f, ...)
{
  gamma <- step
  if(!is.function(step)) gamma <- function(k) step


  args <- list(...)
  if(length(args) == 1 && is.list(args[[1]])) args <- args[[1]]

  theta.tilde <- theta0
  theta.t <- matrix( rep(theta0, m+1), nrow = m+1)
  grad.f.tilde <- sapply(1:n, function(i) do.call(grad.fi, c(list(theta.tilde, i), args)))

  f.value <- rep(NA, niter+1)
  f.value[1] <- do.call(f, c(list(theta.tilde), args))

  k <- 1
  while(k < niter  && mean(abs(grad.f.tilde)) > 1e-3)
  {
    for(t in 1:m+1)
    {
      i <- sample(1:n, 1) #Tirage dans une uniform

      grad.f.hat <- do.call(grad.fi, c(list(theta.t[t-1,], i), args))#approxMCMC()

      d <- grad.f.hat+ mean(grad.f.tilde) - grad.f.tilde[i]
      theta.t[t,] <- prox(theta.t[t-1,] - gamma(k)*d, gamma(k), 1, 0)
    }
    theta.tilde <- apply(theta.t, 2, mean)
    grad.f.tilde <- sapply(1:n, function(i) do.call(grad.fi, c(list(theta.tilde, i), args)))

    # print(mean(grad.f.tilde))
    f.value[k+1] <- do.call(f, c(list(theta.tilde), args))
    theta.t[1,] <- theta.tilde

    k <- k + 1
  }

  theta.tilde <- matrix(theta.tilde, nrow = 1)
  attr(theta.tilde, 'f.value') <- na.omit(f.value)

  return(theta.tilde)
}
```


```{r SPGD res}
model <- SAEM_model(
  function(sigma2, ...) - n/(2*sigma2),
  function(phi1, phi2, phi3, beta, ...) mean( (Y - get_obs(phi1, phi2, phi3, beta) )^2 ),
  noise.name = 'sigma2',

  # === Variable Latente === #
  latent_vars = list(
    # === Non linear model === #
    latent_variable('phi', dim = G, size = 3, prior = list(mean = 'mu', variance = 'omega2') )
    )
)
Phi <- model@Phi$eval

l <- function(beta, phi1, phi2, phi3, Phi, ... ) 
  Phi%a%1 * mean( (Y - get_obs(phi1, phi2, phi3, beta) )^2 ) /n

grad.li <- function(beta, i, phi1, phi2, phi3, Phi,...) 
  Phi%a%1 * mean( (Y[i-1+1:nt] - get_obs_i(phi1, phi2, phi3, beta, i) )*get_m_denom_i(phi1, phi2, phi3, beta, i) )* U[i,] /n




res <- SPGD(500, 10, theta0 = matrix(rep(0, p), nrow = 1), n = N,
            step = burnin_fct(200, 0.8, 1e-5), grad.li, l, 
            var.true$phi1, var.true$phi2, var.true$phi3, Phi = do.call(Phi, param))

as.numeric(beta)
plot(attr(res,'f.value'))
as.numeric(res)
sum(beta - round(as.numeric(res)))
```





