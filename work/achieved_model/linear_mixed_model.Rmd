---
title: "SAEM - linear mixed model"
author: "Antoine caillebotte"
date: "`r Sys.time()`"
output: html_document
---
  
<style type="text/css">
.main-container {
  max-width: 1000px;
  margin-left: auto;
  margin-right: auto;
}
</style>
  
```{r setup, include = F}
library(knitr)
library(kableExtra)

rm(list = ls())

opts_chunk$set(echo = T, message = F, warning = F,
               fig.weightedidth = 12,
               fig.asp = 0.8,
               out.weightedidth = "100%")

# require(ggplot2)
# require(reshape2)
# require(dplyr)
# require(tidyr)
# 
# source('R/include.R')

require(SAEM4JLS)
require(tictoc)
```

# Data generation

$$Y_{i,j} = a + (b+Z_i)\times t_j + \epsilon _{i,j}$$

```{r init}
param <- list( sigma2 = 0.1, gamma2 = 4, a = 4, b = 10)

n  <- 200 #nombre de courbe
J  <- 20  #nombre d'observation
tj <- seq(0,1, length.out = J) %>% matrix(nrow = 1)

Z   <- rnorm(n, 0, sqrt(param$gamma2)) %>% matrix(ncol = 1)
eps <- rnorm(n*J, 0, sqrt(param$sigma2))

dt <- data.frame(id = rep(1:n, each = J) %>% factor,
                 t = rep(tj, times = n),
                 obs = param$a + as.numeric(t( (param$b+Z) %*% tj)) + eps )

dt %>%
  ggplot(aes(t,obs, col = id)) + geom_line() + theme(legend.position = 'null')
```

$$\log f(Y, Z ; \theta) = \langle \Phi(\theta) ; S(Y,Z) \rangle - \psi(\theta)$$

```{r init SAEM}
#Calcul des constantes
mat12 <- mean(tj)
mat21 <- sum(tj)
mat22 <-sum(tj^2)

mat <- matrix(c(1, mat21, mat12, mat22 ), ncol = 2, nrow = 2)

Phi <- function(sigma2, gamma2, a, b) 
  c(-mat22/(2*sigma2)-1/(2*gamma2), 1/sigma2, -sum((a+b*tj)*tj)/sigma2 )

S <- function(Z) c(sum(Z^2), sum(dt$obs * as.numeric(t(Z%*%tj))) , sum(Z))
```

## Metropolis Hastings

```{r MH}
loglik.z <- function(x, Phi) 
{ 
  stat <- S(x)
  sum(Phi*stat)
}

Z.MH <- matrix(rnorm(n), ncol = 1) #valeur initial
Z.MH <- MH_High_Dim_para(500, Z.MH, sd = 0.1, loglik.z, do.call(Phi, param), 
                           verbatim = T, cores = future::availableCores()-2)

plot(Z.MH)

# burn in des premières valeurs
z <- MH_burnin(Z.MH, 250)
#Moyennes et variance sachant Y de Z
est <- attr(z, 'value') %>% group_by(id) %>% summarise(mu = mean(V1), sd = sd(V1))

sd.true <- sqrt((sum(tj^2)/param$sigma2 + 1/param$gamma2)^-1)
#mu.true <- 1:n %>% sapply( function(i) o2.true/param$sigma2 * sum( (Y[i,] -param$a - param$b*tj)*tj) )

mu.true <- dt %>% group_by(id) %>% summarise(mu = sd.true^2/param$sigma2* sum((obs - param$a -param$b*t)*t)) %>% { .$mu }

#Calcule de l'erreur moyenne des estimations des moyennes et variances
mean( abs(est$mu-mu.true)/abs(mu.true) )
mean( abs(est$sd-sd.true)/abs(sd.true) )

```


# SAEM

### initialisation
```{r SAEM init}
# --- Nombre iteration --- #
M <- 1
u <- function(k) ifelse(k < 100, 1, 1/(k-99) )
#---
Sh <- 0

para <- list( sigma2 = 0.5,
               gamma2 = 2,
               a = 2,
               b = 5 )

ZgivenY <- 1:M %>% lapply(function(i) rnorm(n, 0,1) %>% matrix(ncol = 1))
```

## Boucle

```{r SAEM, message=FALSE}
#Fonction qui renvoie les simultations de Z sachant Y à chaque iteration
sim <- function(niter, Phih, ZgivenY)
{
  M <- length(ZgivenY)
  ZgivenY <- 1:M %>% lapply( function(i) 
    MH_High_Dim_para(niter, ZgivenY[[i]], sd = 0.1, loglik.z, Phih, 
                           cores = future::availableCores()-2) )
  list(Z = ZgivenY)
}

maxi <- function(S)
{
  Phi <- c(mean(dt$obs) - S[3]/n*mean(tj) ,  sum(dt$obs * dt$t)/n - S[3]/n*mean(tj)  )
  res <- solve(mat, Phi)
  
  a <- res[1] ; b <- res[2]
  
  sigma2 <- (sum( (dt$obs - a - b * dt$t)^2 ) - 
               2*(S[2] - sum( ( a +  b*tj)*tj ) * S[3] ) + 
               S[1]*mat22 ) /(n*J)
  
  return(list(sigma2 = sigma2, gamma2 = S[1]/n, a = a, b = b))
}
# Valeur empirique
maxi(S(Z))

niter <- 25 #nombre d'itération du SEAM
n.MH <- 10 #nombre d'itération lors de la simulation
tic()
res <- SAEM(niter, n.MH, u, para, Phi, S, list(Z = ZgivenY), sim, maxi, eps = 1e-1, verbatim = T)
toc()

plot(res)
plot(res$Z$Z[[1]], dim = n)
```




