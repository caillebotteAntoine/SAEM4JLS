---
title: "SAEM - linear mixed model"
author: "Antoine caillebotte"
date: "`r Sys.time()`"
output: html_document
---
  
<style type="text/css">
.main-container {
  max-width: 1000px;
  margin-left: auto;
  margin-right: auto;
}
</style>
  
```{r setup, include = F}
library(knitr)
library(kableExtra)

rm(list = ls())

opts_chunk$set(echo = T, message = F, warning = F,
               fig.weightedidth = 12,
               fig.asp = 0.8,
               out.weightedidth = "100%")

# require(ggplot2)
# require(reshape2)
# require(dplyr)
# require(tidyr)
# 
# source('R/include.R')

require(SAEM4JLS)
```

# Data generation

$$Y_{i,j} = a + (b+Z_i)\times t_j + \epsilon _{i,j}$$

```{r init}
param <- list( sigma2 = 0.1, gamma2 = 4, a = 3, b = 5)

n  <- 40 #nombre de courbe
J  <- 20  #nombre d'observation
tj <- seq(0,1, length.out = J) 

Z   <- rnorm(n, 0, sqrt(param$gamma2))
eps <- rnorm(n*J, 0, sqrt(param$sigma2)) %>% matrix(ncol = n)

Y <- param$a + tj * matrix(rep(param$b+Z, each = J), nrow = J) + eps

as_tibble(Y) %>% mutate(t = 1:nrow(.)) %>% melt(id = 't') %>%
  ggplot(aes(t,value, col = variable)) + geom_line() + theme(legend.position = 'null')
```

$$\log f(Y, Z ; \theta) = \langle \Phi(\theta) ; S(Y,Z) \rangle - \psi(\theta)$$

```{r setup SAEM}
#Calcul des constantes
mat12 <- mean(tj)
mat21 <- sum(tj)
mat22 <-sum(tj^2)

mat <- matrix(c(1, mat21, mat12, mat22 ), ncol = 2, nrow = 2)

Phi <- function(sigma2, gamma2, a, b) 
  c(-mat22/(2*sigma2)-1/(2*gamma2), 1/sigma2, -sum((a+b*tj)*tj)/sigma2 )

S <- function(Z) c(sum(Z^2), tj %*% Y %*% Z, sum(Z))

psi <- function(sigma2, gamma2, a, b) n*J/2*log(2*pi*sigma2) + n/2 *log(2*pi*gamma2) + 1/(2*sigma2) * sum((Y-a-b*tj)^2)
```

## Metropolis Hastings

```{r MH}
transi.z <- function(x) rnorm(length(x), x, 0.01)
loglik.z <- function(x, Phi) 
{ 
  stat <- S(x)
  sum(Phi*stat)
}

Z.MH <- matrix(rnorm(n), ncol = 1) #valeur initial
Z.MH <- MH_High_Dim(7500, Z.MH, transi.z, loglik.z, do.call(Phi, param), verbatim = T)

v <- attr(Z.MH, "value")
v %>% mutate(composante = factor(rep(1:length(Z.MH), max(v$iter)+1) )) %>% melt(id = c('iter', 'composante')) %>%
  ggplot(aes(iter, value, col = composante)) + geom_line() + theme(legend.position = 'null') +
  labs(title = 'Resultat de Metropolis Hastings', x = 'iteration', y = 'valeur de Z')


#Fonction retournant les moyennes et variance sachant Y de Z
omega2 <- function(tj, sigma2, gamma2) (sum(tj^2)/sigma2 + 1/gamma2)^-1 # test : omega2(tj, sum(tj^2), 3)
mu <- function(omega2, sigma2, Y, tj, a, b) omega2/sigma2 * apply((Y - a - b*tj)*tj ,2, sum) # test : mu(2,28, 1:3+1+2*1:3, 1:3, 1, 2)


# burn in des 1500 premières valeurs
z <- MH_burnin(Z.MH, 5000) %>% mutate(composante = factor(rep(1:length(Z.MH), nrow(.)/length(Z.MH)) ))
#Moyennes et variance sachant Y de Z
est <- z %>% group_by(composante) %>% summarise(mu = mean(x), o2 = var(x))

o2.true <- omega2(tj, param$sigma2, param$gamma2) 
mu.true <- mu(o2.true, param$sigma2, Y, tj, param$a, param$b)

#Calcule de l'erreur moyenne des estimations des moyennes et variances
mean( abs(est$mu-mu.true)/abs(mu.true) )
mean( abs(est$o2-o2.true)/abs(o2.true) )
```


# SAEM

### initialisation
```{r SAEM init}
# --- Nombre iteration --- #
M <- 1
u <- function(k) ifelse(k < 100, 1, 1/(k-99) )
#---
Sh <- 0

para <- list( sigma2 = sample(1:5, size = 1),
               gamma2 = sample(1:5, size = 1),
               a = sample(1:5, size = 1),
               b = sample(1:5, size = 1) )

ZgivenY <- 1:M %>% lapply(function(i) rnorm(n, 0,1) )
```

## Boucle

```{r SAEM}
#Fonction qui renvoie les simultations de Z sachant Y à chaque iteration
sim <- function(niter, Phih, ZgivenY)
{
  ZgivenY <- ZgivenY %>% lapply( function(z) 
    MH_High_Dim(niter, matrix(z, ncol = 1), transi.z, loglik.z, Phih ) )
  list(ZgivenY)
}

maxi <- function(S)
{
  Phi <- c(mean(Y) - S[3]/n*mean(tj) ,  sum(Y*tj)/n - S[3]/n*mean(tj)  )
  res <- solve(mat, Phi)
  
  a <- res[1] ; b <- res[2]
  
  sigma2 <- (sum( (Y - a - b*tj)^2 ) - 
               2*(S[2] - sum( ( a +  b*tj)*tj ) * S[3] ) + 
               S[1]*mat22 ) /(n*J)
  
  return(list(sigma2 = sigma2, gamma2 = S[1]/n, a = a, b = b))
}

niter <- 200
res <- SAEM(niter, 100, u, para, Phi, S, list(ZgivenY), sim, maxi, eps = 1e-2, verbatim = T)
```

```{r res, echo = F}
dt <- res[[1]] %>% as.data.frame %>% na.omit

#Resultat de l'estimations
est <- rbind( param %>% unlist, dt[nrow(dt),]) %>%
  t %>% data.frame

names(est) <- c('Valeur réelle', 'Valeur estimée')
  
est <- est %>%
  mutate( Rrmse = abs(`Valeur réelle` -`Valeur estimée`)/max(abs(`Valeur réelle`)))
 
est %>% t %>%
  knitr::kable(caption = "résultat de l'algo SAEM-MCMC") %>%
  kable_styling(full_width = F)

# MCMC des paramètres
dt %>% mutate(i = 1:nrow(.)) %>% melt(id = 'i') %>%
  ggplot(aes(i, value, col = variable)) + geom_line() +
  labs(title = "représentation de l'algorithme SAEM pour les paramètres",
       x = 'iteration')

# MCMC de Z
v <- attr(res$Z, 'value')[[1]] %>% lapply(function(x) as.numeric(x)) %>% as.data.frame %>% t %>% as.data.frame()

v %>% mutate(i = 1:nrow(.)) %>% melt(id = 'i') %>% #mutate(phi = rep(factor(c(1:F.)), each = nrow(v)*G)) %>%
  ggplot(aes(i, value, col = variable)) + theme(legend.position = 'null') +
  geom_line() + 
  labs(title = "représentation des variables latentes de l'algorithme SAEM ",
       x = 'iteration')
```





